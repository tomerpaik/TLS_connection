import socket
import struct
import os
import time

#SERVER_PREFERRED_CIPHERS = [0xc02f, 0xc030, 0xc02b] # 0xC02F = TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
SERVER_PREFERRED_CIPHERS = [0x002f] # TLS_RSA_WITH_AES_128_CBC_SHA

def parse_client_hello(data):
    """
    Parses the full Client Hello packet.
    Prints all details and returns necessary data for the handshake.
    """
    # --- 1. Handshake Header ---
    ptr = 0
    hs_type = data[ptr]
    ptr += 1

    hs_len_bytes = b'\x00' + data[ptr:ptr + 3]
    hs_len = struct.unpack('!I', hs_len_bytes)[0]
    ptr += 3

    print(f"[+] Handshake Type: {hs_type} (1 = Client Hello)")
    print(f"[+] Handshake Length: {hs_len} bytes")

    # --- 2. Client Hello Body ---
    client_version = data[ptr:ptr + 2]
    ptr += 2
    print(f"[+] Client Version: 0x{client_version.hex()}")

    client_random = data[ptr:ptr + 32]
    ptr += 32
    print(f"[+] Client Random: {client_random.hex()[:10]}... (truncated)")

    session_id_len = data[ptr]
    ptr += 1

    session_id = b''
    if session_id_len > 0:
        session_id = data[ptr:ptr + session_id_len]
        ptr += session_id_len
        print(f"[+] Session ID: {session_id.hex()}")
    else:
        print("[+] Session ID: (empty)")

    cipher_suites_len = struct.unpack('!H', data[ptr:ptr + 2])[0]
    ptr += 2
    print(f"[+] Cipher Suites Length: {cipher_suites_len}")

    ciphers_data = data[ptr: ptr + cipher_suites_len]
    ptr += cipher_suites_len

    client_ciphers = []
    print("[*] Client supports these Ciphers (Hex):")
    for i in range(0, len(ciphers_data), 2):
        # Unpack returns an int (tuple)
        c_code = struct.unpack('!H', ciphers_data[i: i + 2])[0]
        print(f"    - 0x{c_code:04x}")
        client_ciphers.append(c_code)

    print(f"[+] Parsed {len(client_ciphers)} ciphers from client.")

    comp_len = data[ptr]
    ptr += 1
    ptr += comp_len  # Skip compression bytes

    print(f"[+] Ignored Compression & Extensions ({len(data) - ptr} bytes remaining)")

    # Return only what we need for the Server Hello logic
    return session_id, client_ciphers


def build_server_hello(session_id, chosen_cipher_int):
    """Constructs the Server Hello binary packet"""

    # --- 1. Server Hello Body ---
    # Version: TLS 1.2 (0x0303)
    server_version = bytes.fromhex("0303")

    # Random: 32 bytes generated by server
    server_random = os.urandom(32)

    # Session ID: Echo back what client sent (or empty)
    s_id_part = bytes([len(session_id)]) + session_id

    # Cipher Suite: The one we selected
    cipher_suite = struct.pack("!H", chosen_cipher_int)

    # Compression: Null (0x00)
    compression = bytes.fromhex("00")

    body = server_version + server_random + s_id_part + cipher_suite + compression

    # --- 2. Handshake Header ---
    # Type 0x02 = Server Hello
    msg_type = bytes.fromhex("02")
    msg_len = struct.pack("!I", len(body))[1:]  # 3 bytes length

    handshake_msg = msg_type + msg_len + body

    # --- 3. Record Header ---
    # Type 0x16 = Handshake
    rec_type = bytes.fromhex("16")
    rec_ver = bytes.fromhex("0303")
    rec_len = struct.pack("!H", len(handshake_msg))

    return rec_type + rec_ver + rec_len + handshake_msg

def build_certificate_message():
    """Reads server.der and builds the Certificate handshake message"""

    # 1. Read the raw certificate file (DER format)
    try:
        with open("server.der", "rb") as f:
            cert_data = f.read()
    except FileExistsError:
        print("[-] Error: server.der not found! Run the OpenSSL/Python generation script first.")
        return None

    # 2. Build Length Fields (TLS uses 3-byte integers for these)
    l3_len = struct.pack("!I", len(cert_data))[1:]
    total_certs_len = len(cert_data) + 3

    l2_len = struct.pack("!I", total_certs_len)[1:]
    cert_body = l2_len + l3_len + cert_data

    msg_type = bytes.fromhex("0b")
    msg_len = struct.pack("!I", len(cert_body))[1:]
    handshake_msg = msg_type + msg_len + cert_body

    rec_type = bytes.fromhex("16")  # Handshake
    rec_ver = bytes.fromhex("0303")  # TLS 1.2
    rec_len = struct.pack("!H", len(handshake_msg))

    return rec_type + rec_ver + rec_len + handshake_msg


def build_server_hello_done():
    """
    Builds the Server Hello Done message (Empty handshake message)
    """
    # --- Handshake Header ---
    # Type 0x0e = Server Hello Done
    msg_type = bytes.fromhex("0e")
    # Length: 0 bytes (no body)
    msg_len = bytes.fromhex("000000")

    handshake_msg = msg_type + msg_len

    # --- Record Header ---
    rec_type = bytes.fromhex("16")  # Handshake
    rec_ver = bytes.fromhex("0303")  # TLS 1.2
    rec_len = struct.pack("!H", len(handshake_msg))

    return rec_type + rec_ver + rec_len + handshake_msg

def start_server():
    host = '0.0.0.0'
    port = 4433
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((host, port))
    server_socket.listen(1)

    print("[*] Server listening on port 4433...")

    while True:
        client, addr = server_socket.accept()
        print(f"\n[*] Connection from {addr}")

        try:
            # 1. Read Record Header (5 bytes)
            header = client.recv(5)
            if not header: break

            # Unpack header to get length
            content_type, version, length = struct.unpack('!BHH', header)

            if content_type == 22:  # Handshake
                # 2. Read the body
                body = client.recv(length)

                # 3. Parse details (Prints everything + returns data)
                session_id, client_ciphers = parse_client_hello(body)

                # 4. Logic: Choose Cipher
                chosen_cipher = None
                for server_c in SERVER_PREFERRED_CIPHERS:
                    if server_c in client_ciphers:
                        chosen_cipher = server_c
                        break

                if chosen_cipher:
                    print(f"[V] Agreed on Cipher: 0x{chosen_cipher:04x}")

                    # 5. Build and Send Response
                    response = build_server_hello(session_id, chosen_cipher)
                    client.send(response)
                    print("[V] Server Hello sent successfully.")

                    # 6. Send Certificate
                    cert_packet = build_certificate_message()
                    if cert_packet:
                        client.send(cert_packet)
                        print("[V] Certificate sent.")

                    # 7. Send Server Hello Done
                    done_packet = build_server_hello_done()
                    client.send(done_packet)
                    print("[V] Server Hello Done sent.")

                    print("[*] Waiting for Client response...")
                    client_response = client.recv(4096)
                    if client_response:
                        print(f"[V] Received {len(client_response)} bytes from client!")
                        print(f"    Hex Dump: {client_response.hex()[:60]}...")

                        if client_response[0] == 0x16:
                            print("[V] It looks like a valid TLS record!")
                    else:
                        print("[-] Client closed connection without sending data.")

                    # 8. Wait and see what happens
                    print("[*] Waiting 5 seconds...")
                    time.sleep(5)
                else:
                    print("[X] No shared cipher found.")

        except Exception as e:
            print(f"Error: {e}")
        finally:
            client.close()


if __name__ == "__main__":
    start_server()